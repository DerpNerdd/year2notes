Introduction to Node.js 

What is NODEJS
    Node is an enviornment that allows us to run JS outside of the browser
    Built using chrome's V8 JS Engine
    Node has a large and great community that is adding to the libraries avaliable

Differences from Browser to Node  
    There is no DOM (Dom calls error out)
    There is no Window object to reference
    This runs server side apps 
    Great for filesystem (accessing the computer not just the browser)
    They use commonJS so we don't need to worry about ES6 or browser compatibility 

REPL & CLI
    REPL (Read Eval Print Loop) is a terminal command that lets us use Node
    CLI (Command Line Interface) is the better was that we can use Node

Starting REPL
To start up Node all you need to do is type 'node' into the terminal and you will see the terminal type change to node

REPL 101
Repl is kind of like having a small IDE in your terminal you can create variables and call them in the terminal but this is very inefficient and just for playing around
To exit REPL we hit 'ctrl + c'

CLI 
This is the version that runs js files and compiles them for the terminal
If you type in 'node filename.js' the file will be compiled and run without the need for a browser Engine

Globals
    Just like JS, there are several global variables that we are able to use anywhere
    For instance 'console' we dont need to define this, node already knows
    We call these globals

Here are a few globals that you should knows
    __dirname (with 2 __'s)
        Path to current directory
    --filename (with 2 __'s)
        The current file name
    require
        Allows us to use Modules
    module
        Info about the current module
    process
        info about the env where the program is being executed

Modules
    Modules are Node's way of saying files, EVERY >JS FILE IS A MODULE
    We can use these in ES6 but we use the import command
    Node uses 'require' instead of import  


Built-In Modules
There are a lot of built in modules that are useful for different programs
We are going to be using 4 main ones but you can find more int he docs if you want to make your own projects
https://node.js.org/api/documentation.html

OS Module
The OS module is used to return information on the computer and system information on the PC
const os = require(‘os’)

Path Module
The Path module is used for navigating the directions and file paths
This also includes methods that will clean up paths to avoid errors
const path = require(‘path’)

FS Module (File System)
The file system module is extensive and allows interaction between your code and the files on the PC
This has methods to allow reasons, writing, clearing, and combining files (and so much more…)
Because it is so extensive we only import what we need
const {readFileSync, writeFileSync} = require(‘fs’)

HTTP Module
HTTP is all about servers and internet protocol
This library truncates a lot of difficult code into simpler methods and never buffers requests or response, allowing users to stream data
const http = require(‘http’)

Nodemon
Nodemon is a dev dependency that we use to help with node server development
If you ever update any files on a server, then you need to stop and restart the server to load those settings
Nodemon lets us do it automatically

devDependencies
Nodemon is a library that is not not needed for the end user, so loading it on the server would waste space for no reason
Dependencies only used for creating the application are devDependencies
To install dependencies into the dev only space, we use devDependencies
npm i nodemon -d



NPM Scripts
If you look into your package.json, you will also see a scripts object
We have been using this in react without even knowing it you may recognize the commands listed
"scripts": {
    "start": "react-scripts start",
    "build": "CI= react-scripts build",
    "test": "react-scripts test",
    "eject": "react-scripts eject"
  }


Custom Scripts
React builds default scripts that we have been using, but you are able to define your own scripts
Here’s one for nodemon
"scripts": {
    "start": "nodemon"
  }

Asynchronous vs. Synchronous
Asynchronous
Non-blocking architecture
Execution of one task isn’t dependent on another
Tasks can run simultaneously
Synchronous
Blocking architecture
Execution of each operation depends on completing the one before it
Each tasks requires an answer before moving onto the next iteration

Event Loop
The event loop is a key part of how the browser works with async functions and callbacks
It’s very hard to explain all this, but some guy named Philip Roberts does a great job

Hypertext Transfer protocol
HTTP is how we send information from a browser of URL to a server
HTTP is typical way that users ask for information from a server and that is called a request

HTTP Module
Node is excellent at server setup and request handling, this is done through the http module
Here we have methods like http.createServer() that allow us to easily create a new server

createServer
http.createServer() takes in a call back function with 2 parameters, 1 for requests and 1 for response 
    const server = http.createServer((req, res) =>{}) 

Req and Res  
Req is an object represents the HTTP request, typically done through the URL but also through things like fetch()
Res is the respone, or what the server returns to the user to use 
    const server = http.createServer((req, res) =>{}) 

The request object
There is a lot of information stored in the request object, including url, header, and parameters
We are going to start with the url to get the location of the page we are querying
    if (req.url === "/"){}

The respone object
The respone object has a ton of information as well, including format, json, and download
We are going to focus on the required one called .end that ends the respone process

    res.end("Welcome to our home page");
    else { res.status(404).end();}

Promises 
Promises are a special object that holds information about the values received but also whether or not the operation is finished
Promises are asynchronous so we can use them to run code and then we can force the rest of the code to wait on the promise